# SolvedLeetCode

My LeetCode Journal

# Goals

- [ ] Graham-Shmidt Procedure (グラハム・シュミット法)
- [ ] Gauss-Jordan Elimination (ガウス・ジョルダン法)
- [ ] Method of Undetermined Coefficients (Differential Equations) (未定係数法（微分方程式）)
- [ ] Method of Variation of Parameters (Differential Equations) (パラメータの変動法（微分方程式）)
- [ ] Squeeze Theorem (Validation of Limits of two variables) (スクイーズ定理（二変数の極限の検証）)
- [ ] Simplex Method for Linear Programming (線形計画法のシンプレックス法)
- [ ] Determining Feasibility of a Linear Program through Duality Theory (デュアリティ理論を用いた線形計画の実行可能性の判定)
- [ ] Dijkstra's algorithm (Shortest Path Problem of Binary Tree) (ダイクストラのアルゴリズム（二分木の最短経路問題）)

# History

- [X] Palindrome (文字列が回文かどうか特定)
- [X] Length of Last Word (最後の単語の長さ)
- [X] Converting Roman Numerals to Numbers (ローマ数字を数字変換)
- [X] The hare and the tortoise algorithm (ウサギと亀のアルゴリズム)
- [X] Reverse and Balanced String using Stacks (スタックを使用した文字列の逆転とバランス)
- [X] Create a Linked List (連結リストの作成)
- [X] Find Intersection in Linked List (連結リストでの交差点の検出)
- [X] Reverse a Linked List (連結リストの逆転)
- [X] Middle of the Linked List (連結リストの中央)
- [X] kth node of a linked list (連結リストのk番目のノード)
- [X] Determine if linked list is circular (連結リストが循環しているかどうかを判断する)
- [X] Unique pairs of integers that have difference k (差がkのユニークな整数のペア)
- [X] Create a Queue (キューの作成)
- [X] Reverse first k elements of queue (キューの最初のk要素を逆転)
- [X] Reverse the Queue (キューの逆転)
- [X] Create a Stack (スタックの作成)
- [X] Reverse string using a Stack (スタックを使用して文字列を逆転する)
- [X] Determine if brackets are balanced in a string (文字列内の括弧がバランスしているかどうかを判断する)
- [X] Build a pyramid of * from inputs (*からピラミッドを構築する)
- [X] Build a Binary Search Tree (二分探索木を構築する)
- [X] Traverse Through a Binary Search Tree (二分探索木を構築する)
- [X] Find the minimum value and the maximum of a Binary Tree (二分木の最小値を見つける)
- [X] Validate a Binary Search Tree (二分探索木を検証する)
- [X] Delete Element from a list in place (リスト内の要素をその場で削除する)
- [X] Remove Duplicates from a list in place (リスト内の重複をその場で削除する)
- [X] Remove Duplicates of more than 2 from a list in place (リスト内の2つ以上の重複をその場で削除する)
- [X] Find the nth row of a Pascal Triangle (パスカルの三角形の第 n 行を見つける)
- [X] Find the nth number in the Fibonacci Sequence (フィボナッチ数列の第n番目の数を見つける)
- [X] Find the Kth node from the root node in a Binary Search Tree (根ノードから二分探索木内のK番目のノードを見つける)
- [X] Level Order Traversal of a Binary Search Tree (二分探索木のレベル順走査)
- [X] Merge two linked lists at index x and y (リンクされた2つのリストをインデックスxとyでマージ)
- [X] Calculate how many distinct ways to climb a set of n stairs (n段の階段を登る方法の数を計算)
- [X] Merge two sorted Arrays in place by modifying the first list (最初のリストを修正して、場所によって2つのソートされた配列をマージ)
- [X] Calculate the Majority using the Boyer-Moore Majority Vote Algorithm (Boyer-Moore多数決アルゴリズムを使用して多数決を計算)
- [X] Implement the Power Operation (x ^ n) in O(log(N)) time (O(log(N))時間でべき乗演算（x ^ n）を実装)
- [X] Maximize stolen money from adjacent houses with connected security systems. (
  同じ夜に隣接した家を犯すことなく、盗むことができる最大の金額を計算)
- [X] Minimum Cost of Climbing Stairs (階段を登る最小コスト)
- [X] Determining if a Linked List is a Palindrome (連結リストが回文であるかどうかを決定する)
- [X] Delete and Earn (削除して取得)
- [X] Find the longest subsequence in a string (文字列内で最長の部分列を見つける)
- [X] Determine whether the sudoku is valid (Sudokuが有効かどうかを判断)
- [X] Best Time to Buy and Sell Stocks II (株を買い、売る最良のタイミング II)
- [X] Rotate Array in Place (配列をその場で回転させる)
- [X] Nth Element in a Tribonacci (トリボナッチ数列のN番目の要素)
- [X] Finding the Longest Common Subsequence (最長共通部分列の検索)
- [X] Maximum Score from Performing Multiplication Operations (演算操作を実行して得られる最大スコア)
- [X] Find the largest sum of the elements of a subarray of length k (部分配列の長さ k の要素の合計の中で最大の値を取得)
- [X] Maximum Average Subarray (最大平均部分配列)
- [X] Maximum Subarray of Consecutive Ones and K Zeroes (連続する1の最大部分配列とK個の0)
- [X] Number of Connected Components in a Linked List (連結リスト内の連結成分の数)
